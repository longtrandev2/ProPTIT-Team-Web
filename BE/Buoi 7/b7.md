# Triển khai RestfullAPI trong Spring Boot
## 1.1. Cấu trúc dự án

Trong sơ đồ trên chúng ta thấy có các thành phần chính là **controller**, **model**, **repository**, **service** — đây cũng là mô hình cơ bản mà chúng ta sẽ thấy rất nhiều trong các dự án sau này. Dưới đây chúng ta sẽ tìm hiểu về từng thành phần trong mô hình trên.

![alt text](img/struct.png)
---

## 1.2. Cài đặt thư viện

Đầu tiên để chuẩn bị cho việc khởi tạo dự án chúng ta cần phải thêm một số thư viện cần thiết vào `pom.xml`:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
```

---

## 1.3. Controller

**Chức năng:** Controller là một phần quan trọng của ứng dụng RESTful API, nó nhận và xử lý các yêu cầu HTTP từ các client (thường là trình duyệt hoặc ứng dụng di động) và trả về các phản hồi thích hợp.

**Cách sử dụng:** Bạn đánh dấu các lớp với `@RestController` hoặc các chú thích tương tự để chỉ định rằng đây là các controller. Các phương thức bên trong controller được đánh dấu với các chú thích như `@GetMapping`, `@PostMapping`, `@PutMapping`, và `@DeleteMapping` để xác định các endpoint API và xử lý các yêu cầu từ client.

**CategoryController.java**

```java
@RestController
@RequestMapping("v1/category")
public class CategoryController {

    @Autowired
    private CategoryService categoryService;

    @GetMapping("{id}")
    public ResponseEntity<Category> findCategory(@PathVariable Integer id) {
        Optional<Category> categoryOptional = categoryService.findCategory(id);
        return categoryOptional.map(ResponseEntity::ok)
                .orElseGet(() -> new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }

    @GetMapping
    public ResponseEntity<List<Category>> findAll() {
        return ResponseEntity.ok(categoryService.findAll());
    }

    @PostMapping
    public ResponseEntity<Category> save(@RequestBody Category category) {
        return ResponseEntity.ok(categoryService.save(category));
    }

    @PutMapping
    public ResponseEntity<Category> update(@RequestBody Category category) {
        return ResponseEntity.ok(categoryService.update(category));
    }

    @DeleteMapping
    public void delete(@RequestBody Category category) {
         categoryService.delete(category);
    }
}
```

---

## 1.4. Model

**Chức năng:** Model đại diện cho dữ liệu hoặc đối tượng mà bạn muốn truy cập hay cung cấp thông qua API. Nó định nghĩa cấu trúc dữ liệu và các trường của đối tượng.

**Cách sử dụng:** Bạn tạo các lớp model để mô tả cấu trúc dữ liệu và thông tin về các đối tượng mà bạn sẽ thao tác với trong ứng dụng. Đối tượng model này thường được sử dụng trong các phương thức của Controller và Repository để thao tác với dữ liệu.

**Category.java**

```java
@Entity
@Table(name = "category")
@Getter @Setter
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Integer id;

    @Column(name = "name")
    private String name;

    @Column(name = "slug")
    private String slug;
}
```

---

## 1.5. Repository

**Chức năng:** Repository làm nhiệm vụ truy cập và tương tác với cơ sở dữ liệu. Nó cung cấp các phương thức để lưu trữ và truy vấn dữ liệu từ cơ sở dữ liệu.

**Cách sử dụng:** Bạn tạo các interface hoặc lớp repository với các phương thức để thực hiện các thao tác CRUD (Create, Read, Update, Delete) với đối tượng model. Spring Boot thường tích hợp Spring Data JPA để giúp bạn tạo repository một cách dễ dàng.

**CategoryRepository.java**

```java
@Repository
public interface CategoryRepository extends JpaRepository<Category, Integer> {
}
```

---

## 1.6. Service

**Chức năng:** Service làm nhiệm vụ kết nối giữa Controller và Repository. Nó chứa logic kinh doanh, kiểm tra quyền truy cập, xử lý nghiệp vụ và gọi các phương thức từ Repository để truy cập hoặc cập nhật dữ liệu.

**Cách sử dụng:** Bạn tạo các lớp service để xử lý logic nghiệp vụ. Các controller gọi các phương thức từ service để thực hiện các tác vụ nghiệp vụ. Điều này giúp tách biệt logic nghiệp vụ và logic truy cập dữ liệu, làm cho mã nguồn dễ quản lý và bảo trì.

**CategoryService.java**

```java
public interface CategoryService {
    Optional<Category> findCategory(Integer id);
    List<Category> findAll();
    Category save(Category category);
    Category update(Category category);
    void delete(Category category);
}
```

**CategoryServiceImpl.java**

```java
@Service
public class CategoryServiceImpl implements CategoryService {

    @Autowired
    private CategoryRepository categoryRepository;

    @Override
    public Category save(Category category) {
        return categoryRepository.save(category);
    }

    @Override
    public Optional<Category> findCategory(Integer id) {
        return categoryRepository.findById(id);
    }

    @Override
    public List<Category> findAll() {
        return categoryRepository.findAll();
    }

    @Override
    public Category update(Category category) {
        return categoryRepository.save(category);
    }

    @Override
    public void delete(Category category) {
       categoryRepository.delete(category);
    }
}
```


# JPA là gì? Hibernate là gì?
## 1.JPA
### 1.1 JPA là gì?
JPA (viết tắt của Java Persistence API) là một tiêu chuẩn kỹ thuật trong lĩnh vực phát triển ứng dụng Java để lập trình đối tượng quan hệ (ORM). JPA được cung cấp bởi Oracle và đã được thừa nhận là một tiêu chuẩn quốc tế.

JPA cung cấp cách tiếp cận trừu tượng cho việc lưu trữ và truy xuất dữ liệu trong cơ sở dữ liệu quan hệ. Sử dụng JPA, chúng ta có thể tập trung vào thiết kế ứng dụng của mình hơn là phải lo về cách lưu trữ và truy xuất dữ liệu như thế nào.
### 1.2 Sự cần thiết của JPA trong ứng dụng Java
Trong quá trình phát triển ứng dụng Java, chúng ta không thể tránh khỏi việc tương tác với cơ sở dữ liệu. Vấn đề là, làm thế nào để lưu trữ và truy xuất dữ liệu một cách dễ dàng và hiệu quả?

Một giải pháp là sử dụng **JDBC (Java Database Connectivity)**, một API được cung cấp bởi Sun Microsystems để tương tác với cơ sở dữ liệu. Tuy nhiên, với JDBC, chúng ta cần phải viết rất nhiều code để thực hiện các hoạt động đơn giản như việc lấy và cập nhật dữ liệu. Điều này có thể làm cho ứng dụng của chúng ta trở nên phức tạp và khó bảo trì.

Vì vậy, JPA ra đời nhằm giải quyết vấn đề này bằng cách giảm bớt sự phức tạp của việc tương tác với cơ sở dữ liệu. Với JPA, ta có thể sử dụng đối tượng Java để lưu trữ và truy xuất dữ liệu. Hơn nữa, JPA sẽ tự động chuyển đổi các đối tượng thành các câu truy vấn SQL để thực hiện việc lưu trữ và truy xuất, giúp lập trình viên chúng ta tập trung vào việc phát triển tính năng của ứng dụng mà không phải lo nhiều về SQL phức tạp.
### 1.3 Vai trò của JPA trong phát triển ứng dụng
JPA là một công nghệ quan trọng trong việc phát triển ứng dụng Java, bởi vì nó giúp:

- **Viết code ít hơn**: Sử dụng JPA, chúng ta có thể sử dụng các đối tượng Java thay vì phải viết các câu truy vấn SQL hoặc sử dụng JDBC trực tiếp. Điều này làm cho code trở nên ngắn gọn hơn và dễ đọc hơn, giảm thiểu tối đa boilerplate code.
- **Dễ bảo trì**: Với JPA, việc thay đổi cấu trúc cơ sở dữ liệu trở nên dễ dàng hơn. Chúng ta chỉ cần thay đổi định nghĩa của đối tượng Java và JPA sẽ tự động áp dụng các thay đổi này vào cơ sở dữ liệu tương ứng.
- **Hiệu suất cao**: JPA giúp tối ưu hóa việc truy xuất và lưu trữ dữ liệu trong cơ sở dữ liệu. Nó sử dụng các kỹ thuật như lazy loading và caching để giảm thiểu số lần truy cập vào cơ sở dữ liệu.
## 2. ORM là gì
### 2.1 Một số ORM framework hỗ trợ JPA
**ORM (Object-Relational Mapping)** là một kỹ thuật trong lập trình để ánh xạ các đối tượng Java vào cơ sở dữ liệu quan hệ. Khi sử dụng ORM, chúng ta có thể làm việc với cơ sở dữ liệu thông qua các đối tượng Java, thay vì phải sử dụng các câu truy vấn SQL trực tiếp.
![alt text](img/ORM.png)
Có nhiều framework hỗ trợ ORM và JPA được liệt kê phía dưới:

- **Hibernate**: Hibernate là một trong những framework ORM phổ biến nhất và cũng là backend mặc định cho JPA. Nó cung cấp các tính năng mạnh mẽ và linh hoạt cho việc tương tác với cơ sở dữ liệu quan hệ.
- **EclipseLink**: EclipseLink là một framework ORM mạnh mẽ khác được sử dụng rộng rãi trong cộng đồng Java. Nó cũng hỗ trợ đầy đủ JPA.
- **OpenJPA**: OpenJPA là một framework ORM được phát triển bởi Apache. Nó cung cấp một loạt các tính năng để làm việc với cơ sở dữ liệu quan hệ và hỗ trợ đầy đủ JPA.
## 3. Java Persistence API cơ bản
### 3.1 Kiến trúc JPA

Để hiểu rõ cách JPA hoạt động, chúng ta cần tìm hiểu về một số thành phần chính của nó.

### Các thành phần cơ bản trong JPA

#### 3.1.1 Định nghĩa Entity

Trong JPA, một **Entity** là một đối tượng Java ánh xạ vào một bảng trong cơ sở dữ liệu. Chúng ta có thể hiểu là mối quan hệ 1-1. Đối tượng Entity chứa thông tin về cấu trúc và dữ liệu của bảng.

Để định nghĩa một Entity trong JPA, chúng ta có thể sử dụng các annotation như `@Entity`, `@Table`, `@Column`, vv.

#### Ví dụ

```java
@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name")
    private String name;
    
    // getters and setters
}
```

Ở ví dụ trên, `Employee` được đánh dấu là một Entity bằng cách sử dụng annotation `@Entity`.
Sẽ ánh xạ vào bảng `"employees"` trong cơ sở dữ liệu.
Thuộc tính `id` được đánh dấu là khóa chính bằng cách sử dụng annotation `@Id`.
Các thuộc tính khác được ánh xạ vào các cột của bảng bằng cách sử dụng annotation `@Column`.

### 3.1.2 Quản lý Entity Manager

**Entity Manager** là một thành phần quan trọng trong JPA.
Nó làm nhiệm vụ quản lý các đối tượng Entity và từ đó chúng ta có thể sử dụng Entity Manager để thực hiện các hoạt động CRUD (Create, Read, Update, Delete) trên cơ sở dữ liệu.

#### Ví dụ

```java
public void createEmployee(Employee employee) {
    EntityManager entityManager = // lấy Entity Manager từ EntityManagerFactory
    
    entityManager.persist(employee); // thêm đối tượng vào cơ sở dữ liệu
}
```

Trong ví dụ trên, chúng ta sử dụng phương thức `persist()` của **Entity Manager** để thêm một đối tượng `Employee` vào cơ sở dữ liệu.

---

### 3.1.3 Entity Transaction

Trong JPA, mỗi hoạt động liên quan đến cơ sở dữ liệu sẽ được thực hiện trong một **transaction**.
Transaction là một tập hợp các hoạt động ghi và đọc dữ liệu liên quan mà thường được thực hiện cùng nhau và được xem như là một thao tác duy nhất.
Việc sử dụng các thao tác liên quan trong cùng một Transaction sẽ giúp đảm bảo **tính toàn vẹn của dữ liệu** khi thực hiện.

#### Ví dụ

```java
public void updateEmployeeName(long id, String newName) {
    EntityManager entityManager = // lấy Entity Manager từ EntityManagerFactory
    
    EntityTransaction transaction = entityManager.getTransaction();
    transaction.begin(); // bắt đầu transaction
    
    Employee employee = entityManager.find(Employee.class, id); // tìm kiếm đối tượng Employee theo id
    employee.setName(newName); // thay đổi tên của Employee
    
    transaction.commit(); // kết thúc transaction và lưu các thay đổi vào cơ sở dữ liệu
}
```

Trong ví dụ trên:

* Sử dụng phương thức `getTransaction()` của **Entity Manager** để lấy **Entity Transaction**.
* Bắt đầu transaction bằng `begin()`.
* Thực hiện các hoạt động liên quan đến cơ sở dữ liệu.
* Cuối cùng gọi `commit()` để lưu thay đổi vào cơ sở dữ liệu.

---

### 3.1.4 Quản lý Persistence Context

**Persistence Context** là một trong những khái niệm quan trọng trong JPA, là một vùng nhớ tạm thời được quản lý bởi **Entity Manager** và chứa các đối tượng đã được truy xuất từ cơ sở dữ liệu.

Khi chúng ta lấy một đối tượng từ cơ sở dữ liệu bằng Entity Manager, đối tượng này được lưu trong Persistence Context.
Khi bạn thay đổi đối tượng trong Persistence Context, JPA sẽ **tự động theo dõi các thay đổi này** và cập nhật chúng vào cơ sở dữ liệu khi transaction kết thúc.

---

## 4. Tại sao nên dùng JPA

### 4.1 No-code Repository

Một trong những lợi ích lớn nhất của JPA là chúng ta **không cần phải viết mã SQL hay DAO (Data Access Object)** để làm việc với cơ sở dữ liệu.
Thay vào đó, JPA cung cấp **Repository Interfaces** để thực hiện các hoạt động CRUD.

**JPA cung cấp các phương thức thao tác với cơ sở dữ liệu - Nguồn: Sendvjs Medium**

#### Ví dụ

```java
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    List<Employee> findAll();
}
```

Điều này giúp giảm thiểu rất nhiều công việc lặp lại và **mã boilerplate code** mà chúng ta thường phải viết khi sử dụng JDBC trực tiếp.

---

### 4.2 Khả năng mở rộng

Với JPA, chúng ta có thể **thay đổi cơ sở dữ liệu mà không cần sửa đổi mã nguồn ứng dụng**.
Điều này làm cho việc di động giữa các hệ thống cơ sở dữ liệu khác nhau dễ dàng hơn.

Ngoài ra, JPA còn cho phép chúng ta mở rộng ứng dụng dễ dàng bằng cách **thêm mới các Entity và Repository** mà không cần phải sửa đổi mã nguồn đã có.

---

## 5. So sánh JPA và Hibernate


JPA và Hibernate là hai khái niệm liên quan đến **ánh xạ quan hệ đối tượng (ORM)** trong Java.
Với ORM, như đã đề cập ở phía trên, là một kỹ thuật cho phép **chuyển đổi các đối tượng Java thành các bản ghi trong cơ sở dữ liệu quan hệ và ngược lại**.

Từ đó, chúng ta có thể thấy được **JPA** và **Hibernate** có một số điểm khác nhau như sau:

| Tiêu chí               | JPA                                            | Hibernate                                                      |
| ---------------------- | ---------------------------------------------- | -------------------------------------------------------------- |
| **Bản chất**           | Là một tiêu chuẩn (Specification)              | Là một triển khai (Implementation) của JPA                     |
| **Ngôn ngữ truy vấn**  | JPQL (Java Persistence Query Language)         | HQL (Hibernate Query Language)                                 |
| **Tính mở rộng**       | Tuân thủ tiêu chuẩn, cung cấp tính năng cơ bản | Mở rộng tiêu chuẩn JPA, cung cấp thêm nhiều tính năng nâng cao |
| **Bộ nhớ đệm (Cache)** | Hỗ trợ 2 loại: Entity Cache, Query Cache       | Hỗ trợ thêm Collection Cache                                   |
| **Tính tương thích**   | Được hỗ trợ bởi tất cả các nhà cung cấp JPA    | Chỉ hỗ trợ riêng cho Hibernate                                 |

Tóm lại, **JPA** và **Hibernate** là hai khái niệm liên quan nhưng khác nhau về ORM trong Java:

* JPA là **một tiêu chuẩn cho ORM**.
* Hibernate là **một triển khai của JPA**, đồng thời mở rộng JPA với nhiều tính năng mạnh mẽ hơn.

Tuy nhiên, việc sử dụng các tính năng dành riêng cho Hibernate có thể gây ra **sự phụ thuộc vào nhà cung cấp** và **khó chuyển đổi** sang các triển khai JPA khác.
Do đó, chúng ta nên cân nhắc kỹ trước khi sử dụng Hibernate hoặc JPA cho dự án của mình.

## 6. Hibernate

### 6.1 Hibernate là gì?

**Hibernate** là một thư viện **ORM (Object Relational Mapping)** mã nguồn mở giúp lập trình viên viết ứng dụng Java có thể **map các objects (POJO)** với **hệ quản trị cơ sở dữ liệu quan hệ**,  
và hỗ trợ thực hiện các khái niệm **lập trình hướng đối tượng** với **cơ sở dữ liệu quan hệ**.

![alt text](img/hibernatearchi.png)
---

### 6.2 Hibernate 

#### 6.2.1 Persistence Object
Chính là các **POJO object** map với các **table** tương ứng của cơ sở dữ liệu quan hệ.  
Nó như là những “thùng xe” chứa dữ liệu từ ứng dụng để ghi xuống database, hay chứa dữ liệu tải lên ứng dụng từ database.

#### 6.2.2 Session Factory
Là một **interface** giúp tạo ra **session** kết nối đến database bằng cách đọc các cấu hình trong Hibernate configuration.  
Mỗi một database phải có một **session factory**.

Ví dụ:  
Nếu ta sử dụng **MySQL** và **Oracle** cho ứng dụng Java của mình thì ta cần có một `SessionFactory` cho MySQL, và một `SessionFactory` cho Oracle.

#### 6.2.3 Hibernate Session
Mỗi một đối tượng `Session` được `SessionFactory` tạo ra sẽ tạo **một kết nối** đến database.

#### 6.2.4 Transaction
Là **transaction** đảm bảo tính toàn vẹn của phiên làm việc với cơ sở dữ liệu.  
Tức là nếu có một lỗi xảy ra trong transaction thì tất cả các tác vụ thực hiện sẽ thất bại.

#### 6.2.5 Query
Hibernate cung cấp các câu truy vấn **HQL (Hibernate Query Language)** tới database và map kết quả trả về với đối tượng tương ứng của ứng dụng Java.

---


### 6.3 Tại sao phải dùng Hibernate thay JDBC

#### 6.3.1 Object Mapping
Với **JDBC** ta phải map các trường trong bảng với các thuộc tính của Java object một cách **“thủ công”**.  
Với **Hibernate**, việc này được hỗ trợ **“tự động”** thông qua các file cấu hình map XML hoặc sử dụng **annotation**.

#### JDBC sẽ map Java object với table như sau:

```java
// rs là ResultSet trả về từ câu query get dữ liệu bảng user.
List users = new ArrayList();
while (rs.next()) {
     User user = new User();
     user.setUserId(rs.getString("userNo"));
     user.setName(rs.getString("firstName"));
     user.setEmail(rs.getString("lastName"));
     users.add(user);
}
```

####  Cũng với table user đó, sử dụng annotation để Hibernate map “tự động”:

```java
@Entity
@Table(name = "user")
public class UserModel {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private BigInteger userNo;

    @NotEmpty
    @Column(name = "lastName")
    private String email;

    public BigInteger getUserNo() {
        return this.userNo;
    }
    public void setUserNo(BigInteger userNo) {
        this.userNo = userNo;
    }
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}
```

---

#### 6.3.2 HQL

Hibernate cung cấp các câu lệnh truy vấn tương tự SQL.
HQL của Hibernate hỗ trợ đầy đủ các truy vấn đa hình: **kế thừa (inheritance)**, **đa hình (polymorphism)**, và **liên kết (association)**.

---

#### 6.3.3 Database Independent

Code sử dụng Hibernate là **độc lập với hệ quản trị cơ sở dữ liệu**,
nghĩa là ta không cần thay đổi câu lệnh HQL khi chuyển từ MySQL sang Oracle hay các hệ quản trị khác.
Chỉ cần thay đổi thông tin cấu hình trong file cấu hình.

```properties
# used MySQL
com.mysql.jdbc.Driver

# used Oracle
oracle.jdbc.driver.OracleDriver
```

#### Ví dụ:

Khi muốn lấy 10 bản ghi dữ liệu của một table từ 2 CSDL khác nhau:

**Với JDBC:**

```sql
# MySQL
SELECT column_name FROM table_name ORDER BY column_name ASC LIMIT 10; 

# SQL Server 
SELECT TOP 10 column_name FROM table_name ORDER BY column_name ASC;
```

**Với Hibernate:**

```java
session.createQuery("SELECT E.id FROM Employee E ORDER BY E.id ASC")
       .setMaxResults(10)
       .list();
```

Câu truy vấn **không thay đổi** dù bạn dùng MySQL hay SQL Server.

---

#### 6.3.4 Minimize Code Changes

Khi ta thay đổi (thêm) cột vào bảng:

**Với JDBC, ta phải thay đổi:**

* Thêm thuộc tính vào POJO class.
* Thay đổi method chứa câu truy vấn “select”, “insert”, “update” để bổ sung cột mới.
* Có thể có rất nhiều method, nhiều class chứa các câu truy vấn như trên.

**Với Hibernate, ta chỉ cần:**

* Thêm thuộc tính vào POJO class.
* Cập nhật Hibernate XML mapping file để thêm map column – property.

→ Chỉ thay đổi **2 file** là xong.

---

#### 6.3.5 Lazy Loading

Với những ứng dụng Java làm việc với cơ sở dữ liệu lớn hàng trăm triệu bản ghi, việc sử dụng **Lazy Loading** mang lại lợi ích rất lớn.
Nó giống như việc ta có thể **bẻ từng chiếc đũa** của bó đũa to thay vì bẻ cả bó cùng lúc.

Ví dụ:
Bảng `user` có quan hệ **một-nhiều** với bảng `document`.
Nếu dữ liệu document rất lớn, việc load toàn bộ cùng lúc sẽ tốn bộ nhớ.
Hibernate cho phép ta **chỉ tải dữ liệu khi cần**:

```java
@OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
private Set documents = new HashSet();

// Lấy user
User user = (User) session.get(User.class, new Integer(100));

// Lúc này Hibernate mới fetch documents cho user 100
documents = user.getDocuments();
```

---

#### 6.3.6 Loại bỏ Try-Catch Blocks

Khi thao tác với JDBC, nếu lỗi xảy ra sẽ có `SQLException` bắn ra, nên ta phải dùng `try-catch` để xử lý.
Hibernate xử lý việc này bằng cách **override toàn bộ JDBC exception** thành **Unchecked Exception**,
vì vậy ta **không cần viết try-catch** trong code nữa.

---

#### 6.3.7 Quản lý Commit/Rollback Transaction

**Transaction** là nhóm các hoạt động với database của một tác vụ.
Nếu một hoạt động thất bại thì toàn bộ tác vụ cũng thất bại.

**Với JDBC:**

* Lập trình viên phải chủ động gọi `commit` hoặc `rollback`.

**Với Hibernate:**

* Hibernate **tự động quản lý transaction**, giúp đảm bảo tính toàn vẹn dữ liệu.

---

#### 6.3.8 Hibernate Caching

Hibernate cung cấp cơ chế **bộ nhớ đệm (cache)** giúp **giảm số lần truy cập database**,
từ đó **tăng hiệu năng** cho ứng dụng.

* Hibernate lưu trữ các đối tượng trong session khi transaction được kích hoạt.
* Khi một query được thực hiện liên tục, giá trị đã lưu trong session được sử dụng lại.
* Khi một transaction mới bắt đầu, dữ liệu được lấy lại từ database và được lưu vào session mới.

Hibernate cung cấp **hai cấp độ cache**:

* **Level 1 Cache** (mặc định, theo session)
* **Level 2 Cache** (chia sẻ giữa các session)

---

# Kiến trúc 4 lớp Spring Boot
## 1. Các thành phần cốt lõi của Spring Boot

Spring Boot chủ yếu sở hữu bốn thành phần chính:

- **Spring Boot Starters**  
- **Spring Boot AutoConfigurator**  
- **Spring Boot CLI**  
- **Spring Boot Actuator**

**LƯU Ý:** Ngoài bốn thành phần chính này, Spring Boot còn có thêm hai thành phần nữa:

- **Spring Initializr**  
- **Spring Boot IDEs**

Để nhanh chóng khởi tạo các dự án Spring Boot mới, chúng ta có thể sử dụng giao diện web **Spring Initializr** tại URL: https://start.spring.io. Chúng ta có nhiều IDE hỗ trợ Spring Boot như **Eclipse IDE**, **IntelliJ IDEA**, **Spring STS Suite**, v.v. Chúng ta sẽ đi sâu vào hai thành phần này trong các bài viết tới.

Còn bây giờ, chúng ta sẽ lần lượt phân tích chi tiết bốn thành phần chính của Spring Boot.

---

## 2. Kiến trúc của Spring Boot

### 2.1 Spring Boot Starter

**Spring Boot Starters** là một trong những tính năng hay thành phần cốt lõi quan trọng nhất của Spring Boot Framework. Nhiệm vụ chính của Spring Boot Starter là **nhóm các dependency phổ biến hoặc có liên quan lại** thành **một dependency duy nhất**. Chúng ta sẽ khám phá chi tiết tuyên bố này với một ví dụ.

Ví dụ điển hình, chúng ta muốn phát triển một **Spring Web Application** với **Tomcat WebServer**. Khi đó, chúng ta cần thêm các dependency JAR tối thiểu sau vào `pom.xml` (Maven) hoặc `build.gradle` (Gradle):

- File JAR **Spring core** (`spring-core-xx.jar`)  
- File JAR **Spring Web** (`spring-web-xx.jar`)  
- File JAR **Spring Web MVC** (`spring-webmvc-xx.jar`)  
- File JAR **Servlet** (`servlet-xx.jar`)  

Nếu chúng ta muốn thêm chức năng cơ sở dữ liệu, cần bổ sung các JAR liên quan đến database như **Spring JDBC**, **Spring ORM**, **Spring Transaction**:

- File JAR **Spring JDBC** (`spring-jdbc-xx.jar`)  
- File JAR **Spring ORM** (`spring-orm-xx.jar`)  
- File JAR **Spring Transaction** (`spring-transaction-xx.jar`)  

Việc khai báo **quá nhiều dependency** trong các file build là một công việc tẻ nhạt và cồng kềnh, đồng thời làm tăng kích thước file build. Vậy giải pháp để tránh việc định nghĩa quá nhiều dependency trong các file build của chúng ta là gì?

**Giải pháp chính** là thành phần **Spring Boot Starter**. Spring Boot Starter **kết hợp tất cả các JAR liên quan vào một file JAR duy nhất**, cho phép chúng ta chỉ cần **thêm một dependency duy nhất** vào file build của mình.

- Thay vì phải thêm 4 file JAR riêng lẻ như trên vào file build, chúng ta chỉ cần thêm **duy nhất một file JAR**: `spring-boot-starter-web`.  
- Khi thêm `spring-boot-starter-web`, Spring Boot sẽ **tự động tải tất cả các JAR cần thiết** và thêm chúng vào **classpath** của dự án.

_Tương tự, file JAR_ `spring-boot-starter-logging` _sẽ tải tất cả các JAR dependency của nó như_ `jcl-over-slf4j`, `jul-to-slf4j`, `log4j-over-slf4j`, `logback-classic` _vào classpath của dự án._

**Tóm tắt:**

- Spring Boot Starter **giảm thiểu** việc khai báo nhiều dependency.  
- Spring Boot Starter **đơn giản hóa** các dependency của dự án build.

---

### 2.2 Spring Boot AutoConfigurator

Một thành phần cốt lõi quan trọng khác của Spring Boot Framework là **Spring Boot AutoConfigurator**. Hầu hết các nhà phê bình Spring IO (Spring Framework) đều cho rằng:  
“Phát triển một ứng dụng dựa trên Spring đòi hỏi rất nhiều cấu hình (XML hoặc Annotation)”.

**Giải pháp**: **Spring Boot AutoConfigurator**.

Nhiệm vụ chính của Spring Boot AutoConfigurator là **giảm thiểu cấu hình Spring**. Khi phát triển ứng dụng bằng Spring Boot:

- **Không cần** định nghĩa cấu hình XML.  
- **Gần như không cần** hoặc chỉ cần **cấu hình Annotation tối thiểu**.  
- Thành phần AutoConfigurator sẽ **tự cung cấp** các thông tin cấu hình cần thiết.

Ví dụ, với một ứng dụng **Spring MVC** truyền thống, cần rất nhiều XML (views, view resolvers, …). Nhưng với Spring Boot:

- Chỉ cần dùng `spring-boot-starter-web` trong file build, **AutoConfigurator** sẽ **tự động giải quyết** các **views**, **view resolvers**, v.v.

Và Spring Boot cũng **giảm thiểu cấu hình Annotation**. Nếu sử dụng `@SpringBootApplication` ở cấp độ class, **AutoConfigurator** sẽ tự động thêm tất cả annotation cần thiết vào bytecode lớp Java.

```java
@Target(value=TYPE)
@Retention(value=RUNTIME)
@Documented
@Inherited
@Configuration
@EnableAutoConfiguration
@ComponentScan
public @interface SpringBootApplication {}
```

Điều đó có nghĩa:
`@SpringBootApplication = @Configuration + @ComponentScan + @EnableAutoConfiguration`.

**LƯU Ý:**

* Nói ngắn gọn, **Spring Boot Starter** giảm bớt **dependency** của bản dựng và **Spring Boot AutoConfigurator** giảm bớt **cấu hình Spring**.
* Spring Boot Starter có **dependency** với Spring Boot AutoConfigurator, **Starter tự động kích hoạt AutoConfigurator**.

---

### 2.3 Spring Boot CLI

**Spring Boot CLI (Command Line Interface)** là một phần mềm giúp chạy và kiểm tra ứng dụng Spring Boot **từ cửa sổ lệnh**. Khi chạy ứng dụng bằng CLI, nó **tự động** sử dụng **Starters** và **AutoConfigurator** để giải quyết dependency và thực thi ứng dụng.

Chúng ta thậm chí có thể chạy **Spring Web** chỉ với các lệnh CLI đơn giản. Spring Boot CLI giới thiệu lệnh `spring` để thực thi **Groovy Scripts** từ cửa sổ lệnh.

**Ví dụ:**

```bash
spring run HelloWorld.groovy
```

Ở đây, `HelloWorld.groovy` là tên file script Groovy. Tương tự như Java (`.java`), script Groovy có đuôi `.groovy`. Lệnh `spring` sẽ thực thi script và tạo ra kết quả.

(Phần CLI đòi hỏi các bước như cài đặt, thiết lập, phát triển một ứng dụng đơn giản và kiểm tra. Sẽ có bài viết khác thảo luận chi tiết với ví dụ.)

---

### 2.4 Spring Boot Actuator

Thành phần **Spring Boot Actuator** cung cấp nhiều tính năng, trong đó có hai tính năng chính:

* **Management EndPoints** cho ứng dụng Spring Boot.
* **Metrics** của ứng dụng Spring Boot.

Khi chạy ứng dụng Spring Boot Web bằng CLI, Actuator mặc định cung cấp **hostname** là `localhost` và **cổng** là `8080`.
Có thể truy cập ứng dụng bằng endpoint: `https://localhost:8080/`.

Chúng ta sử dụng các phương thức HTTP như **GET** và **POST** để làm việc với **Management EndPoints** do Actuator cung cấp. (Chi tiết sẽ được bàn sâu ở các bài viết sau.)

---

## Cơ chế hoạt động bên trong của Spring Boot Framework

Luôn nên hiểu cách Spring Boot giúp **giảm bớt dependency** trong quá trình build, **giảm bớt cấu hình Spring**, v.v. — tức là hiểu **under-the-hood**.

Nếu quen với **Groovy**, bạn sẽ thấy điều này khá tự nhiên:
Trong Groovy, khi biên dịch script bằng `groovyc`, trình biên dịch **tự động thêm** một số **import mặc định** để biên dịch. Ngoài ra, Groovy có cơ chế **Resolver** để **tự động tìm và thêm** các JAR cần thiết vào classpath.

Spring Boot **sử dụng Groovy ở bên trong** để tự động thêm một số thành phần mặc định như **các lệnh import**, **phương thức `main()`**, v.v.

**Grape** là công cụ **giải quyết dependency nhúng** trong Groovy (một **dependency manager** tích hợp).
Grape cho phép nhanh chóng **thêm dependency từ kho Maven** vào classpath dự án để **giảm thiểu định nghĩa file build**.



# Request flow (dòng chảy xử lý request)
# Cấu hình DataSource
# Tìm hiểu các Annotation : @RestController, @Service, @Repository, @Entity, @Table, @Id, @Transactional, @Query ...
# Bài tập: Chọn 1 module của 1 đề tài trong sheet bên dưới, làm 1 ứng dụng với module đó. Dùng @RestController để viết endpoint của API, dùng @Service để xử lý các logic CRUD, @Repository để xử lý thao tác với database, @Entity để tạo các ORM với DB
# Lưu ý áp dụng tất cả các Annotation đã tìm hiểu
