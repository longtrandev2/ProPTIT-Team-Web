# Spring Security là gì? Cơ chế hoạt động của Spring Security


---

## 1. Spring Security là gì? Giới thiệu về Spring Security

### 1.1. Spring Security là gì?

Spring Security là một **framework bảo mật mạnh mẽ** dành cho các ứng dụng Java, được phát triển bởi **SpringSource** (hiện thuộc **Pivotal**, sau này là VMware). Đây là một trong những framework bảo mật phổ biến và được sử dụng rộng rãi nhất trong hệ sinh thái Spring.

Spring Security cung cấp **cơ chế xác thực (Authentication)** và **phân quyền (Authorization)** cho ứng dụng, giúp bảo vệ hệ thống khỏi các truy cập trái phép và các lỗ hổng bảo mật phổ biến.

---

### 1.2. Các chuẩn và giao thức được Spring Security hỗ trợ

Spring Security hỗ trợ nhiều tiêu chuẩn và giao thức bảo mật hiện đại, bao gồm:

* HTTPS
* OAuth 2.0 / OAuth 2.1
* JWT (JSON Web Token)
* LDAP
* SAML 2.0
* OpenID Connect (OIDC)

Điều này cho phép Spring Security được sử dụng linh hoạt trong các hệ thống:

* Monolithic application
* Microservices
* REST API
* SPA (React, Angular, Vue)
* Mobile backend

---

### 1.3. Kiến trúc và khả năng tích hợp

Spring Security được thiết kế theo **kiến trúc plugin**, cho phép:

* Tùy biến cao
* Mở rộng dễ dàng
* Thay thế từng thành phần riêng lẻ

Framework này tích hợp chặt chẽ với:

* Spring Boot
* Spring MVC
* Spring Data
* Spring Cloud
* Spring WebFlux

Điều này giúp việc triển khai bảo mật trở nên **nhanh chóng và nhất quán** trong toàn bộ ứng dụng.

---

## 2. Cơ chế hoạt động của Spring Security

### 2.1. Mô hình hoạt động tổng quát

Spring Security hoạt động theo mô hình **client–server**.

Quy trình tổng quát:

1. Client gửi HTTP request đến server
2. Request đi qua **Spring Security Filter Chain**
3. Spring Security:

   * Xác thực danh tính (Authentication)
   * Kiểm tra quyền truy cập (Authorization)
4. Nếu hợp lệ → request được chuyển đến controller
5. Nếu không hợp lệ → trả về lỗi bảo mật (401 / 403)
![alt text](img/filter-chain.webp)
---

### 2.2. Filter Chain trong Spring Security

Trọng tâm của Spring Security là **Security Filter Chain**.

* Mỗi request đều phải đi qua chuỗi filter này
* Mỗi filter đảm nhận **một nhiệm vụ cụ thể**

Một số filter quan trọng:

* `SecurityContextPersistenceFilter`
* `UsernamePasswordAuthenticationFilter`
* `BasicAuthenticationFilter`
* `BearerTokenAuthenticationFilter`
* `ExceptionTranslationFilter`
* `FilterSecurityInterceptor`

Các filter này can thiệp trực tiếp vào **request** và **response**.

---

### 2.3. Event và xử lý sự kiện bảo mật

Khi request **không đáp ứng điều kiện bảo mật**, Spring Security sẽ:

* Ném exception
* Phát sinh các **security event**

Ứng dụng có thể:

* Lắng nghe event
* Ghi log
* Gửi email
* Hiển thị thông báo lỗi tùy chỉnh

Nếu request hợp lệ, quá trình xử lý tiếp tục bình thường.

---

### 2.4. Ba thành phần cốt lõi

Cơ chế bảo mật của Spring Security xoay quanh ba thành phần chính:

1. Authentication
2. Authorization
3. Authentication Provider

---

## 3. Các thành phần cơ bản của Spring Security

---

## 3.1. Authentication trong Spring Security

### 3.1.1. Authentication là gì?

Authentication là quá trình **xác thực danh tính**, trả lời cho câu hỏi:

> “Bạn là ai?”

Khi người dùng đăng nhập, hệ thống sẽ kiểm tra thông tin xác thực để đảm bảo người dùng là hợp lệ.
![alt text](img/authentication-1.webp)
Thông tin xác thực có thể bao gồm:

* Username / Password
* Token (JWT)
* API Key
* Sinh trắc học (vân tay, khuôn mặt)

---

### 3.1.2. Spring Security hỗ trợ các hình thức xác thực

Spring Security hỗ trợ nhiều cơ chế xác thực:

* Form-based Authentication
* HTTP Basic Authentication
* Custom Login Page
* Pre-authenticated Authentication
* Token-based Authentication (JWT, OAuth2)

---

### 3.1.3. Stateful và Stateless Authentication
![alt text](img/State.png)
#### Stateful Authentication

* Thông tin đăng nhập được lưu trong **HTTP Session**
* Mỗi request sử dụng session để xác định người dùng
* Phù hợp với web truyền thống (MVC)

#### Stateless Authentication

* Không lưu session trên server
* Sử dụng token (JWT)
* Phù hợp với REST API, Microservices

---

### 3.1.4. SecurityContext và SecurityContextHolder (Bổ sung)

Sau khi xác thực thành công:

* Thông tin Authentication được lưu trong `SecurityContext`
* `SecurityContext` được quản lý bởi `SecurityContextHolder`
* Controller và Service có thể truy cập thông tin người dùng hiện tại

---

## 3.2. Authorization trong Spring Security

### 3.2.1. Authorization là gì?

Authorization là quá trình **xác định quyền truy cập**, trả lời cho câu hỏi:

> “Bạn được phép làm gì?”

Spring Security kiểm tra xem người dùng có quyền:

* Truy cập tài nguyên
* Thực hiện hành động
![alt text](img/Authorization.png)
---

### 3.2.2. Các yếu tố trong Authorization

Authorization dựa trên:

* Role
* Permission
* Group
* Policy
* Expression-based rules

---

### 3.2.3. Phân quyền trong Spring Security

Spring Security hỗ trợ phân quyền thông qua:

* Annotation (`@PreAuthorize`, `@Secured`)
* Java Config
* XML Config

---

### 3.2.4. AccessDecisionManager

`AccessDecisionManager` chịu trách nhiệm **đưa ra quyết định cuối cùng** về quyền truy cập.

Một số implementation phổ biến:

* `AffirmativeBased`
* `ConsensusBased`
* `UnanimousBased`

```java
	
void decide(Authentication authentication, Object object,
			Collection<ConfigAttribute> configAttributes) throws AccessDeniedException,
			InsufficientAuthenticationException;

boolean supports(ConfigAttribute attribute);

boolean supports(Class<?> clazz);

}
```

---

### 3.2.5. AccessDecisionVoter

**AccessDecisionVoter**: là một **interface** định nghĩa phương thức `vote()` để đưa ra quyết định về quyền hạn của người dùng hoặc ứng dụng. **AccessDecisionVoter** cũng định nghĩa phương thức `supports()` để kiểm tra xem một loại tài nguyên hoặc hành động có được hỗ trợ hay không. **AccessDecisionVoter** có thể được cài đặt bởi các lớp con như **RoleVoter**, **AuthenticatedVoter**, **WebExpressionVoter**.

![alt text](img/Voting.png)
---

### 3.2.6. SecurityExpressionHandler

**SecurityExpressionHandler**: cũng là **interface** định nghĩa phương thức `createSecurityExpressionRoot`() để tạo ra một đối tượng **SecurityExpressionRoot** chứa các biểu thức bảo mật cho người dùng hoặc ứng dụng. **SecurityExpressionHandler** có thể được cài đặt bởi các lớp con như **WebSecurityExpressionHandler**, **MethodSecurityExpressionHandler**. Dùng để xử lý các **biểu thức bảo mật**, ví dụ:

* `hasRole('ADMIN')`
* `hasAuthority('READ')`
* `isAuthenticated()`

---

## 3.3. Authentication Provider

Authentication Provider là thành phần chịu trách nhiệm **xác minh thông tin đăng nhập**. Ví dụ, khi một người dùng đăng nhập vào hệ thống, Authentication Provider sẽ kiểm tra thông tin đăng nhập của người dùng và trả về kết quả xác thực.

* Được sử dụng bởi `AuthenticationManager`
* Mỗi provider xử lý **một loại Authentication cụ thể**

Ví dụ:

* `UsernamePasswordAuthenticationToken`
* `JwtAuthenticationToken`
* `PreAuthenticatedAuthenticationToken`

---

## 4. Các tính năng nâng cao của Spring Security

Spring Security cung cấp nhiều cơ chế bảo mật nâng cao:

* CSRF Protection
* Session Management
* Password Encoding (BCrypt, Argon2)
* OAuth2 Client
* OAuth2 Resource Server
* Method-level Security
* CORS configuration

Các tính năng này có thể cấu hình bằng:

* Java Config
* Annotation
* XML

---

## 5. Ưu và nhược điểm của Spring Security

### Ưu điểm

* Framework bảo mật mạnh mẽ, chuẩn công nghiệp
* Hỗ trợ nhiều giao thức bảo mật
* Tích hợp chặt chẽ với Spring
* Cộng đồng lớn, tài liệu phong phú

---

### Nhược điểm

* Cấu hình phức tạp, khó học cho người mới
* Đường cong học tập cao
* Cần kiến thức nền về bảo mật
* Có thể gây overhead với hệ thống yêu cầu hiệu năng cực cao

---

## 6. Tổng kết về Spring Security

Spring Security là một trong những framework bảo mật mạnh và phổ biến nhất cho ứng dụng Java. Nó cung cấp đầy đủ cơ chế xác thực, phân quyền, và các biện pháp bảo vệ nâng cao để đảm bảo an toàn cho hệ thống.

Tuy nhiên, để sử dụng Spring Security hiệu quả, lập trình viên cần có:

* Kiến thức nền về bảo mật
* Hiểu rõ kiến trúc Spring
* Nắm vững cơ chế Authentication và Authorization

Nếu được triển khai đúng cách, Spring Security sẽ giúp ứng dụng của bạn **an toàn, linh hoạt và dễ mở rộng** trong môi trường thực tế.

# JWT là gì?
## 2.1 JWT (JSON Web Token) là gì
**JWT** (**J**SON **W**eb **T**oken) là một tiêu chuẩn mã nguồn mở (RFC 7519) dùng để truyền tải thông tin an toàn, gọn nhẹ và khép kín giữa các bên tham gia dưới format **JSON**.

Thông tin được chia sẻ trong JWT được xác thực và tin cậy thông qua chữ ký số (Digital signature). Các bên sẽ sử dụng mật mã khoá đối xứng (cùng với **HMAC**) hoặc dùng mật mã khoá công khai (cùng **public** và **private** **key**) để thực hiện ký số (**signed**).
![alt text](img/JWT.png)
`header.payload.signature`

## 2.2 Cấu trúc của JSON Web Token:
JWT gồm 3 phần chính, và phần tách nhau bằng một dấu chấm (.):

- Header
- Payload
- Signature

Vì vậy, JWT sẽ có dạng như sau :

```bash
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```   
![alt text](img/JWT-Structure.png)
## 2.2.1 Header

Header thông thường sẽ bao gồm 2 thành phần, gồm: **Kiểu token** (với trường hợp này luôn luôn là JWT) và **thuật toán mã hoá** được sử dụng (ví dụ như HMAC hoặc RSA).

Do đó, Header của JWT sẽ có dạng như sau:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}

```

Sau đó, đoạn này sẽ được encoding (base64Encode) và trở thành chuỗi đầu tiên trong 3 chuỗi JWT.

---

## 2.2.2 Payload

Payload trong JWT chứa các **claims**.

Trong lĩnh vực an toàn thông tin, claims đề cập đến sự tuyên bố quyền truy cập hoặc quyền sử dụng tài nguyên.

Claims là tập hợp các thông tin đại diện cho một thực thể (object) (ví dụ: `user_id`) và một số thông tin đi kèm. Claims sẽ có dạng **Key - Value**. Do đó, chúng ta có thể hiểu rằng, claims ám chỉ việc yêu cầu truy xuất tài nguyên cho object tương ứng.

Có 3 kiểu claims, bao gồm: **registered**, **public**, và **private claims**.

### 2.2.2.1 Registered Claims

Registered Claims là các thành phần được xác định trước của claims. Thành phần này mặc dù không bắt buộc, nhưng là thành phần nên có để cung cấp một số chức năng và thông tin hữu ích.

Một số registered claims bao gồm:

* **iss (issuer):** Tổ chức, đơn vị cung cấp, phát hành JWT.
* **sub (subject):** Chủ thể của JWT, xác định rằng đây là người sở hữu hoặc có quyền truy cập các resource (tài nguyên).
* **aud (audience):** Được hiểu là người nhận thông tin, và có thể xác thực tính hợp lệ của JWT.
* **exp (expiration time):** Thời hạn của JWT, vượt quá thời gian này, JWT được coi là không hợp lệ.

### 2.2.2.2 Public Claims

Public claims là các thành phần được xác định bởi người sử dụng JWT, được sử dụng rộng rãi trong JWT. Mặc dù việc sử dụng public claims không phải là bắt buộc, tuy nhiên để tránh xảy ra xung đột, public claims name được xác định theo danh sách dưới đây:

| Claim Name | Claim Description |
| --- | --- |
| **iss** | Issuer |
| **sub** | Subject |
| **aud** | Audience |
| **exp** | Expiration Time |
| **nbf** | Not Before |
| **iat** | Issued At |
| **jti** | JWT ID |
| **name** | Full name |
| **given_name** | Given name(s) or first name(s) |
| **family_name** | Surname(s) or last name(s) |
| **middle_name** | Middle name(s) |
| **nickname** | Casual name |
| **preferred_username** | Shorthand name by which the End-User wishes to be referred to |
| **profile** | Profile page URL |
| **picture** | Profile picture URL |

**Một số public claims điển hình:**

* **name, given_name, family_name, middle_name:** Thông tin tên nói chung của user.
* **email:** Thông tin email của user.
* **locale:** Địa chỉ của user.
* **profile, picture:** Thông tin của trang web gửi đến.

### 2.2.2.3 Private Claims

Các bên sử dụng JWT có thể sẽ cần sử dụng đến claims không phải là Registered Claims, cũng không được định nghĩa trước như Public Claims. Đây là phần thông tin mà các bên tự thoả thuận với nhau, không có tài liệu hay tiêu chuẩn nào dành cho private claims.

> **Lưu ý:** Tên claims chỉ nên dài ba ký tự vì JWT hướng tới sự nhỏ gọn.

---

## 2.2.3 Signature

Signature là phần cuối cùng của JWT, có chức năng xác thực danh tính người gửi. Để tạo ra một signature chính xác, ta cần encode phần header, phần payload, chọn cryptography (mật mã khoá) thích hợp đã được xác định ở header kèm secret key và thực hiện sign.

Ví dụ, nếu chúng ta lựa chọn hàm HMACSHA256, function thực hiện sign sẽ có dạng như sau:

```bash
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)

```

Cả bên gửi và bên nhận JWT đều sẽ xử dụng hàm này để xác định phần signature, nếu thông tin này của cả 2 bên khác nhau, JWT này được coi là không hợp lệ.

> **Lưu ý:** Chỉ có người có secret key mới có thể sign được một signature phù hợp. Do đó, danh tính của bên gửi được đảm bảo nhờ có signature.

---

## 2.3. Lý do sử dụng JWT

* **Authentication (Xác thực):** JWT được sử dụng để xác thực người dùng trước khi họ truy cập đến tài nguyên trên server.
* **Authorization (Uỷ quyền):** Khi người dùng đăng nhập thành công, application có thể truy cập vào các tài nguyên thay mặt người dùng đó. Các ứng dụng đăng nhập một lần (Single Sign-On SSO) sử dụng JWT thường xuyên vì tính nhỏ gọn và dễ dàng triển khai trên nhiều domain.
* **Trao đổi thông tin an toàn:** JWT được coi là một cách trao đổi thông tin an toàn vì thông tin đã được signed trước khi gửi đi.

---

## 2.4. Ưu điểm của JWT

* **Gọn nhẹ:** JWT nhỏ gọn, chi phí truyền tải thấp giúp tăng hiệu suốt của các ứng dụng.
* **Bảo mật:** JWT sử dụng các mật mã khoá để tiến hành xác thực người danh tính người dùng. Ngoài ra, cấu trúc của JWT cho phép chống giả mạo nên thông tin được đảm bảo an toan trong quá trình trao đổi.
* **Phổ thông:** JWT được sử dụng dựa trên JSON, là một dạng dữ liệu phổ biến, có thể sử dụng ở hầu hết các ngôn ngữ lập trình. Ngoài ra, triển khai JWT tương đối dễ dàng và tích hợp được với nhiều thiết bị, vì JWT đã tương đối phổ biến.

---

## 2.5. Khuyết điểm của JWT

* **Kích thước:** Mặc dù trong tài liệu không ghi cụ thể giới hạn, nhưng do được truyền trên HTTP Header, vì thế, JWT có giới hạn tương đương với HTTP Header (khoảng 8KB).
* **Rủi ro bảo mật:** Khi sử dụng JWT không đúng cách, ví dụ như không kiểm tra tính hợp lệ của signature, không kiểm tra expire time, kẻ tấn công có thể lợi dụng sơ hở để truy cập vào các thông tin trái phép. Ngoài ra, việc để thời gian hết hạn của JWT quá dài cũng có thể tạo ra kẽ hở tương tự.

---

## 2.6. Một số ứng dụng JWT

* **Single Sign-On (SSO):** JWT có thể được sử dụng để cung cấp single sign-on cho người dùng. Điều này cho phép họ đăng nhập vào nhiều ứng dụng chỉ với một tài khoản duy nhất.
* **API Authorization:** JWT thường được sử dụng để phân quyền cho người dùng đến những tài nguyên cụ thể, từ những claims chứa trong JWT đó.
* **User Authentication:** JWT cung cấp khả năng xác thực người dùng và cấp quyền cho họ truy cập vào các tài nguyên mong muốn trong hệ thống.
* **Microservices Communication:** JWT còn có thể sử dụng cho việc giao tiếp giữa các service nhỏ trong hệ thống microservices.

---

## 2.7. Kết luận

JWT thường được sử dụng trong các hệ thống xác thực và ủy quyền, đặc biệt là trong các ứng dụng web và dịch vụ API, nhờ vào tính gọn nhẹ và khả năng tích hợp dễ dàng với các hệ thống khác nhau. Tuy nhiên, việc triển khai JWT cũng cần được thực hiện cẩn thận để tránh các lỗ hổng bảo mật, đảm bảo rằng mã hóa và ký số được thực hiện đúng cách, các token được quản lý hiệu quả.

# Authentication va authorization

Authentication (xác thực) có nghĩa là xác nhận danh tính của riêng bạn, trong khi authorization (ủy quyền) có nghĩa là cấp quyền truy cập vào hệ thống. Nói một cách đơn giản, authentication là quá trình xác minh bạn là ai, trong khi authorization là quá trình xác minh những gì bạn có quyền truy cập.

## Authentication là gì?

Authentication là về việc xác thực thông tin đăng nhập của bạn như tên người dùng hoặc định danh người dùng và mật khẩu để xác minh danh tính của bạn. Hệ thống xác thực danh tính người dùng thông qua mật khẩu đăng nhập. Authentication thường được thực hiện bởi tên người dùng và mật khẩu tuy nhiên nó lại kết hợp với các yếu tố xác thực khác như mã OTP hay mã PIN.

Các nhân tố xác thực (Authentication Factor) mà hệ thống sử dụng để xác minh một danh tính trước khi cấp cho họ quyền truy cập vào thực hiện bất cứ điều gì trên ứng dụng của bạn.

Dựa trên cấp độ bảo mật, Authentication Factor có thể thay đổi theo một trong các cách sau:

* **Single-Factor Authentication (Xác thực một lớp):** Nó là phương thức xác thực đơn giản nhất thường dựa vào mật khẩu đơn giản để cấp cho người dùng quyền truy cập vào một hệ thống cụ thể là một website hoặc network. Người này có thể yêu cầu quyền truy cập vào hệ thống chỉ bằng một trong các thông tin đăng nhập để xác minh danh tính của mình. Ví dụ phổ biến nhất về xác thực một yếu tố sẽ là thông tin đăng nhập chỉ yêu cầu mật khẩu đối với tên người dùng hoặc địa chỉ email.
* **Two-Factor Authentication (Xác thực hai lớp):** Như tên của nó, nó có một quy trình xác minh gồm hai bước, không chỉ yêu cầu tên người dùng và mật khẩu, mà còn một thứ mà chỉ người dùng biết, để đảm bảo mức độ bảo mật bổ sung, chẳng hạn như pin ATM, chỉ người dùng mới biết. Sử dụng tên người dùng và mật khẩu cùng với một thông tin bí mật bổ sung khiến cho những kẻ lừa đảo hầu như không thể đánh cắp dữ liệu có giá trị.
* **Multi-Factor Authentication (Xác thực nhiều lớp):** Nó có một phương thức xác thực tiên tiến nhất sử dụng hai hoặc nhiều mức bảo mật từ các loại xác thực độc lập để cấp quyền truy cập cho người dùng vào hệ thống. Tất cả các yếu tố phải độc lập với nhau để loại bỏ bất kỳ lỗ hổng nào trong hệ thống.

Authentication các có thể kết hợp một hoặc nhiều các yếu tố sau:

* **Password hay Pin:** Là mật khẩu hay mã pin. Mật khẩu là một phương pháp xác thực vô cùng đơn giản, dễ triển khai nên đang được sử dụng rất rộng rãi và phổ biến. Mỗi khi người dùng thực hiện truy cập vào thì mỗi hệ thống đều sẽ lưu lại mật khẩu dưới dạng mã hóa một chiều (các loại mã hóa có thể là md5, sha1, hoặc tự viết cơ chế mã hóa). Đây là tính năng sẽ đảm bảo cho mật khẩu dù bị hack nhưng cũng không thể khôi phục được thành chuỗi gốc. Đây là phương pháp có nhiều biến thể khác nhau như: thiết kế dưới dạng biến thể Swipe Pattern PIN hoặc mật khẩu chỉ bằng cách dùng trong một lần (nó chuyên sử dụng cho những chức năng quan trọng).
* **Security token:** Các mã bảo mật. Đây là phương pháp dựa vào thuật toán mã hóa khóa công cộng và khóa cá nhân để xác thực. Muốn đăng nhập vào hệ thống, thì bạn chỉ cần có khóa cá nhân ở trên máy rồi thực hiện đăng nhập vào hệ thống mà không cần phải nhớ đến những thông tin đăng nhập như việc sử dụng mật khẩu. Thường thì các hệ thống quản trị server sẽ thường xuyên áp dụng biện pháp này.
* **Biometric verification:** Sẽ xác minh sinh trắc học, sử dụng tròng mắt, dấu vân tay hoặc khuôn mặt là một trong những phương pháp xác thực dựa trên các yếu tố đặc trưng của một người. Phương pháp này mang lại ưu điểm là Id và mật khẩu sẽ luôn được đi cùng nhau nên bạn hoàn toàn không cần phải lo lắng bị quên hay lạc mất nó. Mỗi khi bạn muốn đăng nhập lại thì chỉ cần chủ động sử dụng các yếu tố xác thực này một cách dễ dàng, mà không gặp bất kỳ khó khăn nào.

Mặc dù có nhiều phương pháp để có thể xác thực cho một tài khoản, tuy nhiên thì bạn sẽ không thể tránh khỏi những rủi ro như: mất đi mật khẩu, vân tay bị đánh cắp, mất mã khóa cá nhân.

> Tìm hiểu về xác thực và phân quyền trong ứng dụng
> Security key là gì? Xác thực 2 yếu tố “xịn xò” với Security key

## Authorization là gì?

Authorization là quá trình để xác định xem người dùng được xác thực có quyền truy cập vào các tài nguyên cụ thể hay không. Nó xác minh quyền của bạn để cấp cho bạn quyền truy cập vào các tài nguyên như thông tin, cơ sở dữ liệu, file… Authorization thường được đưa ra sau khi xác thực xác nhận các đặc quyền của bạn để thực hiện. Nói một cách đơn giản hơn, nó giống như cho phép ai đó chính thức làm điều gì đó hoặc bất cứ điều gì.

Authorization xảy ra sau khi hệ thống của bạn được authentication (xác thực) thành công, cuối cùng cho phép bạn toàn quyền truy cập các tài nguyên như thông tin, file, cơ sở dữ liệu, quỹ, địa điểm, hầu hết mọi thứ. Nói một cách đơn giản, authorization xác định khả năng của bạn để truy cập hệ thống và ở mức độ nào. Khi danh tính của bạn được hệ thống xác minh sau khi xác thực thành công, bạn sẽ được phép truy cập tài nguyên của hệ thống.

Ví dụ quy trình xác minh và xác nhận mã nhân viên và mật khẩu trong một tổ chức được gọi là Authentication, nhưng xác định nhân viên nào có quyền truy cập vào tầng nào được gọi là Authorization.