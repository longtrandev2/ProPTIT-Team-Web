- [Lưu mật khẩu người dùng, mã hóa và giải mã](#lưu-mật-khẩu-người-dùng-mã-hóa-và-giải-mã)
- [Tấn công CSRF là gì? Cách ngăn chặn?](#tấn-công-csrf-là-gì-cách-ngăn-chặn)
- [CSRF là gì? Tìm hiểu về CSRF và cách phòng chống tấn công hiệu quả](#csrf-là-gì-tìm-hiểu-về-csrf-và-cách-phòng-chống-tấn-công-hiệu-quả)
  - [Vậy CSRF là gì?](#vậy-csrf-là-gì)
  - [Cách thức hoạt động](#cách-thức-hoạt-động)
    - [Ví dụ minh họa](#ví-dụ-minh-họa)
  - [Cách phòng chống tấn công CSRF](#cách-phòng-chống-tấn-công-csrf)
    - [1. Phía User (Người dùng)](#1-phía-user-người-dùng)
    - [2. Phía Server (Máy chủ)](#2-phía-server-máy-chủ)


---


# Bảo Mật Mật Khẩu & Mã Hóa Dữ Liệu: Lý Thuyết Cốt Lõi và Thực Hành (Java)

Trong kỷ nguyên Cloud hiện nay, mật khẩu là chìa khóa vạn năng dẫn vào kho dữ liệu nhạy cảm của doanh nghiệp. Tuy nhiên, chỉ "có" mật khẩu thôi là chưa đủ; chúng ta cần đảm bảo những mật khẩu đó được bảo vệ an toàn tuyệt đối.

Thị trường mã hóa dữ liệu được dự đoán sẽ tăng trưởng từ 14.5 tỷ USD lên 40.3 tỷ USD vào năm 2032. Điều này cho thấy nhu cầu cấp thiết trong việc áp dụng các phương pháp bảo mật tiên tiến.

Bài viết này sẽ giải thích bản chất của mã hóa, phân biệt nó với Hashing (Băm), và cung cấp code mẫu để triển khai trong ứng dụng Java.

---

## 1. Mã hóa là gì? (Encryption)

Mã hóa là quá trình biến đổi dữ liệu từ dạng đọc được (Plaintext) sang dạng không thể đọc được (Ciphertext) bằng các thuật toán. Chỉ những ai có **Khóa giải mã (Decryption Key)** hợp lệ mới có thể khôi phục lại dữ liệu gốc.

**Ví dụ:**

* **Mật khẩu gốc:** `Banana5Cloud9Mouse0`
* **Sau khi mã hóa:** `SxE1y8BIOSdAO/nSGwughmGeO0FN0E0YMIghibgA8Lk=`

Nếu hacker đánh cắp được chuỗi mã hóa này mà không có khóa, dữ liệu đó hoàn toàn vô dụng.

---

## 2. Các phương pháp Mã hóa chính

Có hai loại mã hóa phổ biến mà mọi lập trình viên cần nắm vững:

### A. Mã hóa Đối xứng (Symmetric Encryption)

* **Cơ chế:** Sử dụng **CÙNG MỘT KHÓA** cho cả việc mã hóa và giải mã.
* **Ưu điểm:** Tốc độ nhanh, hiệu quả xử lý dữ liệu lớn.
* **Nhược điểm:** Khó khăn trong việc chia sẻ khóa an toàn (nếu lộ khóa, toàn bộ hệ thống bị vỡ).
* **Thuật toán tiêu biểu:** **AES (Advanced Encryption Standard)** - Tiêu chuẩn vàng hiện nay.

### B. Mã hóa Bất đối xứng (Asymmetric Encryption)

* **Cơ chế:** Sử dụng cặp khóa: **Public Key** (để mã hóa) và **Private Key** (để giải mã).
* **Ưu điểm:** An toàn hơn vì không cần gửi Private Key qua mạng.
* **Nhược điểm:** Tốc độ chậm hơn nhiều so với đối xứng.
* **Thuật toán tiêu biểu:** **RSA**.

---

## 3. Phân biệt Mã hóa (Encryption) và Băm (Hashing)

Đây là phần quan trọng nhất mà nhiều người nhầm lẫn.

| Đặc điểm | Mã hóa (Encryption) | Băm (Hashing) |
| --- | --- | --- |
| **Cơ chế** | Hai chiều (Two-way) | Một chiều (One-way) |
| **Khả năng đảo ngược** | **Có thể** giải mã về dữ liệu gốc nếu có Key. | **Không thể** dịch ngược về dữ liệu gốc. |
| **Mục đích** | Bảo vệ dữ liệu cần sử dụng lại (Số thẻ, CCCD, Email). | Bảo vệ **Mật khẩu**. |
| **Đại diện** | AES, RSA | BCrypt, SHA-256 |

---

## 4. Kỹ thuật Salting (Thêm "Muối")

Hashing đơn thuần có một điểm yếu chết người: **Hai mật khẩu giống nhau sẽ cho ra chuỗi Hash giống nhau.**
Hacker có thể dùng **Rainbow Table** (bảng tra cứu các mã hash phổ biến) để tìm ra mật khẩu gốc.

**Giải pháp - Salting:**
Thêm một chuỗi ngẫu nhiên (Salt) vào mật khẩu trước khi băm.

* User A: `123456` + `Salt_A` -> `Hash_A`
* User B: `123456` + `Salt_B` -> `Hash_B`

Kết quả: Dù mật khẩu giống nhau, hash lưu trong DB vẫn khác nhau hoàn toàn.

---

## 5. Thực Hành: Code ví dụ (Java Spring Boot)

Dưới đây là cách triển khai thực tế cho 2 trường hợp quan trọng nhất: **Lưu mật khẩu (Hashing)** và **Lưu dữ liệu nhạy cảm (Encryption)**.

### Trường hợp 1: Lưu mật khẩu an toàn với BCrypt (Hashing)

**Lý thuyết áp dụng:** BCrypt là thuật toán hashing được thiết kế đặc biệt cho mật khẩu. Nó tự động sinh **Salt** ngẫu nhiên và tích hợp cơ chế làm chậm (Cost factor) để chống Brute-force.

```java
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

public class PasswordService {

    // Strength 12: Độ phức tạp tính toán (Cost factor)
    private final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder(12);

    // 1. ĐĂNG KÝ: Băm mật khẩu để lưu vào DB
    public String hashPassword(String rawPassword) {
        // BCrypt tự động thêm Salt ngẫu nhiên bên trong chuỗi kết quả
        return passwordEncoder.encode(rawPassword);
    }

    // 2. ĐĂNG NHẬP: Kiểm tra mật khẩu
    public boolean checkPassword(String rawPassword, String storedHash) {
        // Hàm matches tự động tách Salt từ storedHash để so sánh
        return passwordEncoder.matches(rawPassword, storedHash);
    }

    public static void main(String[] args) {
        PasswordService service = new PasswordService();
        String myPass = "Banana5Cloud9Mouse0";

        String hashed = service.hashPassword(myPass);
        System.out.println("Hash lưu DB: " + hashed);
        // Output: $2a$12$R9h/cIPz0gi.URNNX3kh2OPST9k.UTzSdVoKgL2x/TEr1tkZG (Ví dụ)

        boolean isMatch = service.checkPassword("Banana5Cloud9Mouse0", hashed);
        System.out.println("Kết quả đăng nhập: " + isMatch); // true
    }
}

```

### Trường hợp 2: Mã hóa dữ liệu nhạy cảm với AES (Encryption)

**Lý thuyết áp dụng:** Dùng cho dữ liệu như số CCCD, số điện thoại. Sử dụng AES-256 chế độ GCM (Galois/Counter Mode) để bảo mật cao nhất.

```java
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Base64;

public class AesEncryptionUtils {
    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 128;

    // Key này phải được bảo mật kỹ (ví dụ lưu trong Vault/Env Variable)
    // 32 bytes = 256 bits
    private static final String SECRET_KEY = "12345678901234567890123456789012"; 

    public static String encrypt(String data) throws Exception {
        // Tạo IV ngẫu nhiên (Bắt buộc cho mỗi lần mã hóa)
        byte[] iv = new byte[GCM_IV_LENGTH];
        new SecureRandom().nextBytes(iv);

        SecretKey key = new SecretKeySpec(SECRET_KEY.getBytes(), "AES");
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
        cipher.init(Cipher.ENCRYPT_MODE, key, spec);

        byte[] cipherText = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));

        // Nối IV + CipherText để lưu trữ (Cần IV để giải mã sau này)
        byte[] encrypted = new byte[iv.length + cipherText.length];
        System.arraycopy(iv, 0, encrypted, 0, iv.length);
        System.arraycopy(cipherText, 0, encrypted, iv.length, cipherText.length);

        return Base64.getEncoder().encodeToString(encrypted);
    }

    public static String decrypt(String encryptedData) throws Exception {
        byte[] decoded = Base64.getDecoder().decode(encryptedData);

        // Tách IV ra
        byte[] iv = new byte[GCM_IV_LENGTH];
        System.arraycopy(decoded, 0, iv, 0, iv.length);

        // Tách CipherText ra
        byte[] cipherText = new byte[decoded.length - iv.length];
        System.arraycopy(decoded, iv.length, cipherText, 0, cipherText.length);

        SecretKey key = new SecretKeySpec(SECRET_KEY.getBytes(), "AES");
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
        cipher.init(Cipher.DECRYPT_MODE, key, spec);

        return new String(cipher.doFinal(cipherText), StandardCharsets.UTF_8);
    }
}

```

---

## 6. Các thuật toán phổ biến nên biết

* **AES (Khuyên dùng):** Tiêu chuẩn vàng cho mã hóa dữ liệu.
* **SHA-256 (SHA-2):** Thuật toán băm phổ biến, nhưng với mật khẩu thì **BCrypt** tốt hơn.
* **BCrypt (Khuyên dùng):** Tự động salt, có cost factor, chống brute-force tốt nhất cho mật khẩu.
* **MD5 / SHA-1 (Tránh xa):** Đã lỗi thời và không còn an toàn.

## 7. Best Practices (Thực hành tốt nhất)

1. **Mã hóa mọi nơi:** Mã hóa cả dữ liệu đang lưu trữ (At rest) và dữ liệu đang truyền tải (In transit - HTTPS).
2. **Không dùng thuật toán cũ:** Tuyệt đối nói không với MD5, DES.
3. **Luôn Salt mật khẩu:** Sử dụng BCrypt/Argon2 để việc này được thực hiện tự động.
4. **Bảo vệ nhiều lớp:** Mã hóa là chưa đủ, hãy áp dụng thêm xác thực 2 lớp (MFA/2FA).

# CSRF là gì? Tìm hiểu về CSRF và cách phòng chống tấn công hiệu quả

Vấn đề bảo mật website có thể nói là rất quan trọng. **CSRF** là một kiểu tấn công diễn ra khá phổ biến hiện nay trên các website không bảo mật. Nếu bạn là một lập trình viên thì cần nắm rõ kiểu tấn công này để đảm bảo tính bảo mật cho ứng dụng web của mình.

## Vậy CSRF là gì?

**CSRF** hay còn gọi là kỹ thuật tấn công "**Cross-site Request Forgery**", nghĩa là kỹ thuật tấn công giả mạo chính chủ thể của nó. CSRF nói đến việc tấn công vào chứng thực request trên web thông qua việc sử dụng **Cookies**.

Đây là nơi mà các hacker có khả năng sử dụng thủ thuật để tạo request mà bạn không hề biết. Vì vậy, một CSRF là hacker lạm dụng sự tin tưởng của một ứng dụng web trên trình duyệt của nạn nhân.

## Cách thức hoạt động

CSRF là một kiểu tấn công gây sự nhầm lẫn, tăng tính xác thực và cấp quyền của nạn nhân khi gửi một request giả mạo đến máy chủ. Vì thế một lỗ hổng CSRF ảnh hưởng đến các quyền của người dùng (ví dụ như quản trị viên), kết quả là chúng truy cập được đầy đủ quyền.

1. Khi gửi một request HTTP, trình duyệt của nạn nhân sẽ nhận về Cookie. Các cookie thường được dùng để lưu trữ một session để định danh người dùng không phải xác thực lại cho mỗi yêu cầu gửi lên.
2. Nếu phiên làm việc đã xác thực của nạn nhân được lưu trữ trong một Cookie vẫn còn hiệu lực, và nếu ứng dụng không bảo mật sẽ dễ bị tấn công CSRF.
3. Kẻ tấn công có thể thử dụng CSRF để chạy bất cứ request nào với ứng dụng web mà ngay cả trang web không thể phân biệt được request nào là thực hay giả mạo.

### Ví dụ minh họa

Để hiểu rõ hơn, giả sử ứng dụng web có một chức năng đơn giản đó là thay đổi mật khẩu người dùng. Việc gửi lên server theo phương thức `HTTP GET` thông thường. Nội dung gửi lên là password mới và confirm lại password vừa nhập:

1. Người dùng đã đăng nhập trên web của bạn, cookie sẽ được tạo và lưu trữ dưới trình duyệt. Khi bạn vào site lần sau bạn không cần phải đăng nhập lại. Giả sử bạn chưa đăng xuất, lúc này cookies của bạn vẫn còn hạn trong phiên làm việc.
2. Lúc này nếu website của bạn mắc lỗi CSRF, người dùng vô tình vào một trang hacker giả mạo với mục đích lấy tài khoản từ ứng dụng web của bạn.
3. Trong trang giả mạo, hacker sẽ dùng script để chạy một URL để cố ý reset mật khẩu người dùng trên trang của bạn:

```http
https://website-cua-ban.com/vulnerabilities/csrf/?password_new=hacked&password_conf=hacked&Change=Change#

```

Như vậy khi Victim (User) vô tình vào trang `web-hacker-gia-mao.com` đã reset password của bản thân tại trang `website-cua-ban.com`. Hacker nếu biết thông tin username sẽ thử vào với password đã cài đặt là `hacked` và có thể vào một cách bình thường.

---

## Cách phòng chống tấn công CSRF

Dựa trên nguyên tắc của CSRF là *"lừa trình duyệt của người dùng (hoặc người dùng) gửi các câu lệnh HTTP"*, thông thường để tránh tấn công ta sẽ chia làm hai đối tượng: phía **Client** (người dùng cuối) và phía **Server**.

> **Có thể bạn quan tâm:**
> * SQL Injection là gì? Cách giảm thiểu và phòng ngừa SQL Injection
> * Những góc khuất "đeo bám" người làm nghề lập trình
> * Cách mà một dòng code đã thay đổi cuộc đời tôi!
> 
> 

### 1. Phía User (Người dùng)

Để tránh trở thành nạn nhân của các cuộc tấn công CSRF nên thực hiện một số lưu ý sau:

* **Đăng xuất (Logout):** Nên đăng xuất khỏi các website quan trọng (Tài khoản ngân hàng, thanh toán trực tuyến, các mạng xã hội, gmail…) khi đã thực hiện xong giao dịch.
* **Thiết bị cá nhân:** Nên login vào một máy riêng và không cho người thứ 2 tiếp xúc với máy đó.
* **Cẩn trọng với liên kết:** Không nên click vào các đường dẫn mà bạn nhận được qua email, qua facebook… Khi bạn đưa chuột qua 1 đường dẫn, phía dưới bên trái của trình duyệt thường có địa chỉ website đích, bạn nên lưu ý để đến đúng trang mình muốn.
* **Không lưu mật khẩu:** Không lưu các thông tin về mật khẩu tại trình duyệt của mình. Không nên chọn các phương thức “đăng nhập lần sau”, “lưu mật khẩu”…
* **Tập trung khi giao dịch:** Trong quá trình thực hiện giao dịch hay vào các website quan trọng không nên vào các website khác, vì có thể chứa các mã khai thác của kẻ tấn công.

### 2. Phía Server (Máy chủ)

Cho đến nay vẫn chưa có biện pháp nào có thể phòng chống triệt để CSRF. Sau đây là một vài kĩ thuật thường được sử dụng:

* **Sử dụng Captcha và thông báo xác nhận:**
* Captcha được sử dụng để nhận biết đối tượng đang thao tác với hệ thống là con người hay không.
* Các thao tác quan trọng như "đăng nhập", "chuyển khoản", "thanh toán" thường hay sử dụng captcha.
* Những chức năng quan trọng như reset mật khẩu, xác nhận thay đổi info của account cũng nên gửi URL qua email đã đăng ký để người dùng có thể click vào xác nhận.


* **Sử dụng `csrf_token`:**
* Token này sẽ thay đổi liên tục trong phiên làm việc, và khi thay đổi thông tin sẽ gửi kèm thông tin token này.
* Nếu token được sinh ra và token được gửi lên không trùng nhau thì loại bỏ request.


* **Sử dụng cookie riêng biệt cho trang Admin:**
* Nên để trang quản trị ở một subdomain riêng để chúng không dùng chung cookies với front-end của sản phẩm.
* Ví dụ: Nên đặt là `admin.topdev.vn` thay vì `topdev.vn/admin`.


* **Kiểm tra IP:**
* Một số hệ thống quan trọng chỉ cho truy cập từ những IP được thiết lập sẵn, hoặc chỉ cấp phép truy cập quản trị qua IP local hoặc VPN.

# CODE MINH HỌA: CSRF PROTECTION TRONG SPRING BOOT

Chúng ta sẽ đi qua 3 kịch bản:

1. **Chưa bảo vệ (Lỗ hổng).**
2. **Bảo vệ ứng dụng Web truyền thống (Thymeleaf/JSP).**
3. **Bảo vệ ứng dụng SPA/REST API (React, Angular...).**

### 1. Kịch bản Lỗ hổng (Khi chưa có CSRF Token)

Giả sử bạn có một API chuyển tiền. Nếu không có CSRF protection, Hacker chỉ cần tạo một form giả và auto-submit.

**Controller (Java):**

```java
@RestController
public class BankController {

    // API này KHÔNG an toàn nếu tắt CSRF
    @PostMapping("/transfer")
    public String transferMoney(@RequestParam String toAccount, @RequestParam double amount) {
        // Logic chuyển tiền...
        return "Đã chuyển " + amount + " tới " + toAccount;
    }
}

```

**Code tấn công của Hacker (file `evil.html`):**

```html
<body onload="document.forms[0].submit()">
    <form action="http://bank.com/transfer" method="POST">
        <input type="hidden" name="toAccount" value="TAI-KHOAN-HACKER">
        <input type="hidden" name="amount" value="1000000">
    </form>
</body>

```

---

### 2. Phòng chống bằng CSRF Token (Web truyền thống - Thymeleaf)

Đây là kỹ thuật **Synchronizer Token Pattern**. Server sinh ra một mã ngẫu nhiên, nhúng vào Form. Hacker không thể biết mã này nên không thể giả mạo Form.

**Cấu hình Spring Security (`SecurityConfig.java`):**
Mặc định Spring Security đã bật CSRF. Bạn chỉ cần đảm bảo không gọi `.csrf(csrf -> csrf.disable())`.

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
        .formLogin(withDefaults());
        // CSRF được bật mặc định cho các method POST/PUT/DELETE
    return http.build();
}

```

**View (Thymeleaf):**
Khi bạn dùng `th:action`, Thymeleaf tự động chèn một input ẩn chứa token.

```html
<form th:action="@{/transfer}" method="post">
    <input type="text" name="toAccount" />
    <button type="submit">Chuyển tiền</button>
</form>

<form action="/transfer" method="post">
    <input type="text" name="toAccount" />
    
    <input type="hidden" name="_csrf" value="a9s8d7-random-token-xyz-123" />
    
    <button type="submit">Chuyển tiền</button>
</form>

```

*Giải thích:* Nếu Hacker dùng form giả mạo như ở phần 1, hắn không thể biết giá trị `a9s8d7-random-token-xyz-123` để điền vào. Server nhận request thiếu token này sẽ trả về lỗi **403 Forbidden**.

---

### 3. Phòng chống cho REST API / Single Page App (React/Angular)

Với SPA, chúng ta không dùng HTML Form, nên không có input ẩn. Chúng ta phải gửi Token qua **Header**.

**Cấu hình Backend (`SecurityConfig.java`):**
Chúng ta cấu hình để Spring gửi Token về Client thông qua **Cookie** (để Javascript đọc được).

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf
            // CookieCsrfTokenRepository: Lưu token vào Cookie tên là XSRF-TOKEN
            // withHttpOnlyFalse(): Cho phép Javascript đọc được cookie này
            .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
        )
        .authorizeHttpRequests(auth -> auth.anyRequest().authenticated());
    return http.build();
}

```

**Code Frontend (Javascript/Fetch API):**
Client phải tự lấy token từ Cookie và gắn vào Header mỗi khi gửi request POST.

```javascript
// 1. Hàm lấy giá trị từ Cookie
function getCookie(name) {
    if (!document.cookie) return null;
    const xsrfCookies = document.cookie.split(';')
        .map(c => c.trim())
        .filter(c => c.startsWith(name + '='));
    if (xsrfCookies.length === 0) return null;
    return decodeURIComponent(xsrfCookies[0].split('=')[1]);
}

// 2. Gửi Request với Token
const csrfToken = getCookie('XSRF-TOKEN'); // Lấy token server gửi về

fetch('/api/transfer', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        // Gửi token kèm theo Header này. 
        // Hacker không thể làm điều này vì hắn không đọc được Cookie của domain bạn (Same-Origin Policy).
        'X-XSRF-TOKEN': csrfToken 
    },
    body: JSON.stringify({
        toAccount: "123456",
        amount: 500000
    })
});

```

---

### 4. Lớp bảo vệ bổ sung: SameSite Cookie

Ngoài CSRF Token, một kỹ thuật hiện đại là chặn trình duyệt gửi Cookie sang trang khác ngay từ đầu bằng thuộc tính `SameSite`.

**Cấu hình trong `application.properties`:**

```properties
# Strict: Cookie chỉ được gửi nếu bạn đang ở chính trang web đó.
# Lax: (Mặc định) Cookie được gửi khi người dùng click link điều hướng, nhưng chặn trong các request POST chéo trang (Form submit).
server.servlet.session.cookie.same-site=Strict

```

Hoặc cấu hình trong Spring Security Config:

```java
@Bean
public CookieSerializer cookieSerializer() {
    DefaultCookieSerializer serializer = new DefaultCookieSerializer();
    serializer.setSameSite("Strict"); // Chặn triệt để request từ bên thứ 3
    return serializer;
}

```

### Tóm lại

1. **Server Rendering (JSP/Thymeleaf):** Spring tự động lo (`<input type="hidden" name="_csrf">`).
2. **REST API:** Cấu hình `CookieCsrfTokenRepository` và Client phải gửi Header `X-XSRF-TOKEN`.
3. **SameSite Cookie:** Nên bật `Strict` hoặc `Lax` như một lớp khóa thứ 2.

